This is a personal project implementing replacements for some `std::vector` and related C++ functionality.

# `Weighted_type`

Similar to `std::optional`. The primary purpose is to perform simple math without overflow or error checking until the final result. This theoretically allows for minimal, yet failsafe code. An invalid `Weighted_type` will propagate its invalid state to other `Weighted_type` variables dependent on it. 

For instance:

```cpp
Weighted_type<int, bool> A1; // Default constructor creates an invalid variable
// A1.Valid() is false
auto A2 = 1 + A1; // A2 becomes invalid due to A1
A2 = 1; // Assign a value to make it valid
A1(false, 0); // Value is 0, but invalid
A1(true, 0); // Value is 0 and valid
auto a1 = A1.Value(); // Get the value (type: int)
auto w1 = A1.Weight(); // Get the weight (type: bool, value: true)
auto A3 = A2 / A1; // Division by zero is avoided; A3 is invalid and A3.Value() == A2.Value()
```

Since A3 is invalid, all comparison operators will return false regardless of the value.

```cpp
auto b1 = A3 > 0; // false
auto b2 = A3 < 0; // false
auto b3 = A3 == 0; // false
auto b4 = A3 != 0; // false
```

Weight can be a float:

```cpp
Weighted_type<float, float> F1(1.0); // Value is 1.0, weight is float(true)
Weighted_type<float, float> F2(0.1, 1.0); // Value is 1.0, weight is 0.1
Weighted_type<float, float> F3;
F3.
```

# `Array_of`

To be continuedâ€¦

`Array_of` is similar to `std::vector`, but is not resizable, intended for embedded systems where memory reallocation is undesirable.
